<<< JAVA 정리 >>>

패키지 사용하는 이유 -> 수많은 클래스들의 관계가 뒤엉키는 것을 방지하기 위해
같은 패키지 안에 들어있으면 -> 그 패키지안에 클래스 막 쓸 수 있음
다른 패키지에 있는 클래스를 사용하려면 -> import쓰거나, 안쓸거면 그냥 패키지.클래스.메서드() 이런식으로 사용가능

빌트인 패키지:
    - 일반적인 import와는 다르게 패키지, 클래스면 없이 접근 가능
    
static 변수 :
    - 메모리에 한 번 할당되어 프로그램이 종료될 떄 비로소 해제됨 (안바뀌는것??)
    - 클래스 자체에 속함(접근방법: 클래스.static변수), 인스턴스에 속한 변수가 아님
    - 모든 인스턴스가 같은 스테틱 변수의 값을 공유하기 떄문에 어디서 접근하든 값이 같음
    - 가비지 컬렉터가 관리하는 영역 밖에 있음 -> 잘못하면 프로그램 종료시까지 메모리가 할당된 채로 낭비될 수 있음
    - 스태틱(데이터) 영역 -> 가장 오랫동안 남아있는 메모리 부분 (전역변수, )
    >> 그니까 내가 A_class의 obj1에서도 staticVar를 접근하면 같은 값이 나오고, A_class의 obj2에서도 staticVar를 접근하면 같은 값이 나온다는것!!! 그 클래스의 인스턴스들에서 공유하는 변수가 정적 변수
    -  

오버라이딩 오버로딩 -> 맨날 헷갈림
    - 오버라이딩: 상속이랑 같이 생각하면 됨, 자식 클래스가 부모 클래스의 메서드를 재정의 할 떄 오버라이딩이라고 함요
                "라이딩"은 말 그대로 어떤 것 위에 덮어씌우는 것을 의미합니다. 
    - 오버로딩: 그냥 하나의 클래스 안에서 입력인자의 개수를 다르게 하는 메서드를 몇개 구현하는 것을 오버로딩이라고 함요
                다양한 형태의 메서드들을 마치 여러 개의 로딩된 것처럼 보여서 "오버로딩"이라는 용어가 선택되었습니다.
                
업캐스팅 다운캐스팅 :
    - 자식 객체지만 타입을 부모의 타입으로 업캐스팅하면 편리함 -> 다운캐스팅은 업캐스팅했던 객체의 타입을 다시 자식 클래스의 타입으로 바꿔(다운)주는 것

참조 자료형:
    - 게터세터로 값을 바꿔주고
    - 변수에 들어가는 건 주소이고, 주소값으로 이동해서 메모리상에 객체가 저장되어있음

부동소수점:
    - 

String 클래스:
    - new 안해도 내부적으로 알아서 객체를 만들어줌
        ex) String str = '안녕하세요'

메이븐? 빌드 자동화 도구
    - 

public static void main 분석:
    -   

System.out.println() 분석:
    - System 클래스의 

예외처리:
    - 컴파일시 잡아내지 못한 에러를 잡아내기 위해서 
    - 컴파일시 잡아내지 못하는 에러? 실행시 사용자가 발생시키는 에러들.. (이상한 것 입력했다거나.. 없는 인덱스에 접근했다거나.. 등등)
    - 이떄 프로그램의 비정상적 종료는 절대 안됨
    - 예외 발생시 바로 예외처리 부분으로 점프

Wrapper 클래스:
    - 아니 이럴거면 걍 원시타입말고 다 객체로 받지.... 해서 생김 ex) int type -> Integer class

제네릭
    - <객체 생성시> 타입을 (나중에) 지정할 수 있게 하기 위해 만들어요

배열과 리스트 차이:
    -  배열은 선언시 크기 확정, 리스트는 필요시 할당하여 효율적임(=가변적임)

인터페이스와 추상 클래스 차이:
    - 